/*
Copyright 1987-2012 Robert B. K. Dewar and Mark Emmer.
Copyright 2012-2013 David Shields

This file is part of Macro SPITBOL.

    Macro SPITBOL is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    Macro SPITBOL is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Macro SPITBOL.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
/	File:  SYSBX.C		Version:  01.06
/	---------------------------------------
/
/	Contents:	Function zysbx
*/

/*
/	zysbx - before execution setup
/
/	Setup here so that all further "standard output" goes to stdout.
/	This allows us to separate compiler/interpreter generated output
/	from output generated by the executing program.
/
/	If the -w command line option has been invoked, this module will
/	write an executable module and terminate.
/
/	If the -y command line option has been invoked, this module will
/	write a save (.spx) file and terminate.

/	Parameters:
/	    None
/	Returns:
/	    Nothing
/	Exits:
/	    None
/
*/

#include "port.h"

zysbx()
{
#if !RUNTIME

    executing = 1;

    if (readshell0) {
        doset(getrdiob(), 0L, 2); // bypass rest of source file
        curfile = inpcnt;	  // skip rest of cmd line files
        swcinp( inpcnt, inpptr ); // v1.07 switch away from source file
    }

#if EXECFILE
    /*
    /   do we need to write an executable module, and if
    /   so does writing it produce an error?
    */
    if ( spitflag & WRTEXE)
    {
        pTSCBLK->len = appendext( *inpptr, BINEXT, pTSCBLK->str, 1 );

        if ( makeexec( pTSCBLK, spitflag & NOEXEC ? 3 : 4 ) )
        {
            wrterr( "Error writing load module." );
            zysej();
        }
    }
#endif					// EXECFILE

    /*
    /   do we need to write a save (.spx) file, and if
    /   so does writing it produce an error?
    */
    if ( spitflag & WRTSAV)
    {
        pTSCBLK->len = appendext( *inpptr, RUNEXT, pTSCBLK->str, 1 );
        if ( makeexec( pTSCBLK, spitflag & NOEXEC ? -3 : -4 ) )
        {
            wrterr( "Error writing save file." );
            zysej();
        }
    }
    /*
    /   Execution does not resume here for dirty load modules.
    /   Because we must allow for new versions with different
    /   size C code, the stacked return addresses are not valid.
    /   Therefore, inter.asm forces a jump to restart code that
    /   eventually jumps to the MINIMAL code following the call
    /   the sysbx call.
    /
    / ***********************************************************
    / * WE DO NOT RETURN HERE.  ANY NEW CODE ADDED HERE MUST BE *
    / * DUPLICATED IN THE RESTART CODE                          *
    / ***********************************************************
    */

    //  execution resumes here when a.out file created with
    //  the -w option is reloaded.

    startbrk();			// turn on Control-C checking

    //  swcoup does real work
    swcoup( outptr );

#else         // !RUNTIME
    __exit(1);
#endif					// !RUNTIME

    return NORMAL_RETURN;
}
